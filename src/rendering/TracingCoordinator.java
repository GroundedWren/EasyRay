package rendering;
import java.io.*;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.*;

import geometry.*;
import acceleration.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * TracingCoordinator coordinates all components of ray tracing.
 * @author alexaulabaugh
 * Reads in the camera specifications, scene specifications, and settings
 * Then traces the rays generated by the camera, returning colors to the camera
 * Instructs the camera to print an image file
 */

public class TracingCoordinator
{
	//All GeometricObjedts in the scene
	private ArrayList<GeometricObject> sceneObjects;
	//All PointLights in the scene
	private ArrayList<PointLight> pointLights;
	//All AreaLights in the scene
	private ArrayList<GeometricObject> emitters;
	private Camera camera;
	//The amount of ambient lighting in the scene
	private double ambient;
	//The intensity of specular highlights
	private double specularWeight;
	//The output image file dimensions & filename
	private TripletVector backgroundColor;
	private int[] outputDim;
	private String outputFilename;
	private String sceneFilename;
	private String cameraFilename;
	//The maximum recursion depth of reflection/refraction
	private int maxRecur;
	//The style of sampling from area emitters
	private String emitterSampleType;
	private int emitterSampleSize;
	//Makes complex geometry run faster
	private AccelerationStructure accelerationStructure;
	//Thread list
	private ArrayList<RayShooter> processingThreads;

	/**
	 * Reads in and parses GeometricObjects and PointLights from a scene file
	 * @param filename the scene file
	 */
	private void buildScene(String filename)
	{
		//default values
		backgroundColor = new TripletVector(0, 0, 0);
		sceneObjects = new ArrayList<GeometricObject>();
		pointLights = new ArrayList<PointLight>();
		emitters = new ArrayList<GeometricObject>();
		emitterSampleType = "None";
		emitterSampleSize = 1;
		//end default
		try
		{
			File sceneFile = new File(filename);
			Scanner sceneFileScanner = new Scanner(sceneFile);
			while(sceneFileScanner.hasNextLine())
			{
				String[] line = sceneFileScanner.nextLine().split(":");
				switch(line[0])
				{
					case "Background":
						String[] rgb = line[1].split(",");
						backgroundColor = new TripletVector(Double.parseDouble(rgb[0])/255.0, Double.parseDouble(rgb[1])/255.0, Double.parseDouble(rgb[2])/255.0);
						break;
					case "EmitterSampleType":
						emitterSampleType = line[1];
						break;
					case "EmitterSampleSize":
						emitterSampleSize = Integer.parseInt(line[1]);
						if(Math.pow((int)Math.sqrt(emitterSampleSize), 2) != emitterSampleSize)
						{
							System.out.println("Error: Emitter Sample Size is not perfect square! Defaulting to no sampling");
							emitterSampleSize = 1;
						}
						break;
					case "Sphere":
						Sphere sphereObj = new Sphere(line[1]);
						sceneObjects.add(sphereObj);
						break;
					case "Plane":
						Plane planeObj = new Plane(line[1]);
						sceneObjects.add(planeObj);
						break;
					case "Triangle":
						Triangle triangleObj = new Triangle(line[1]);
						sceneObjects.add(triangleObj);
						break;
					case "Rectangle":
						Rectangle rectangleObj = new Rectangle(line[1]);
						sceneObjects.add(rectangleObj);
						break;
					case "PointLight":
						String[] params = line[1].split(" ");
						String[] coords = params[0].split(",");
						TripletVector lightLoc = new TripletVector(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]), Double.parseDouble(coords[2]));
						String[] colors = params[1].split(",");
						TripletVector lightCol = new TripletVector(Double.parseDouble(colors[0])/255.0, Double.parseDouble(colors[1])/255.0, Double.parseDouble(colors[2])/255.0);
						pointLights.add(new PointLight(lightLoc, lightCol));
						break;
					case "Mesh":
						TriangleMesh mesh = new TriangleMesh(line[1]);
						for(Triangle t : mesh.getTriangles())
						{
							sceneObjects.add(t);
						}
						break;
				}
			}
			if(emitterSampleSize == 1)
			{
				emitterSampleType = "None";
			}
			sceneFileScanner.close();
			for(GeometricObject object : sceneObjects)
			{
				if(object.isEmitter())
				{
					emitters.add(object);
				}
			}
			accelerationStructure.addGeometricObjectList(sceneObjects);
		}
		catch(Exception e)
		{
			System.out.println("Error: Cannot load scene file: " + filename);
			return;
		}
	}
	
	/**
	 * Reads in and parses a camera specification, then creates a camera
	 * @param filename the camera file
	 */
	private void buildCamera(String filename)
	{
		try
		{
			File cameraFile = new File(filename);
			Scanner cameraFileScanner = new Scanner(cameraFile);
			//Default values
			TripletVector eyePt = new TripletVector(0, 0, 0);
			TripletVector lookat = new TripletVector(0, 0, -1);
			TripletVector up = new TripletVector(0, -1, 0);
			int wres = 500;
			int hres = 500;
			double pwidth = 1;
			double fovDeg = 90;
			String mode = "perspective";
			String sampleType = "None";
			int sampleSize = 1;
			//End default values
			while(cameraFileScanner.hasNextLine())
			{
				String[] line = cameraFileScanner.nextLine().split(":");
				switch(line[0])
				{
					case "Eyepoint":
						String[] eyeCoords = line[1].split(",");
						eyePt = new TripletVector(Double.parseDouble(eyeCoords[0]), Double.parseDouble(eyeCoords[1]), Double.parseDouble(eyeCoords[2]));
						break;
					case "Lookat":
						String[] lookCoords = line[1].split(",");
						lookat = new TripletVector(Double.parseDouble(lookCoords[0]), Double.parseDouble(lookCoords[1]), Double.parseDouble(lookCoords[2]));
						break;
					case "Up":
						String[] upCoords = line[1].split(",");
						up = new TripletVector(Double.parseDouble(upCoords[0]), Double.parseDouble(upCoords[1]), Double.parseDouble(upCoords[2]));
						break;
					case "PixelWidth":
						pwidth = Double.parseDouble(line[1]);
						break;
					case "FOV":
						fovDeg = Double.parseDouble(line[1]);
						break;
					case "wres":
						wres = Integer.parseInt(line[1]);
						break;
					case "hres":
						hres = Integer.parseInt(line[1]);
						break;
					case "mode":
						mode = line[1];
						if(!mode.equals("perspective") && !mode.equals("orthographic"))
						{
							System.out.println("Error: Render Mode: '" + mode + "' Not recognized");
							return;
						}
						break;
					case "SampleType":
						sampleType = line[1];
						break;
					case "SampleSize":
						sampleSize = Integer.parseInt(line[1]);
						if(Math.pow((int)Math.sqrt(sampleSize), 2) != sampleSize)
						{
							System.out.println("Error: Sample Size is not perfect square! Defaulting to no sampling");
							sampleSize = 1;
						}
						break;
				}
			}
			if(sampleSize == 1)
			{
				sampleType = "None";
			}
			camera = new Camera(eyePt, lookat, up, wres, hres, pwidth, fovDeg, mode, sampleType, sampleSize);
			cameraFileScanner.close();
		}
		catch(Exception e)
		{
			System.out.println("Error: Cannot load camera file: " + filename);
			return;
		}
	}
	
	/**
	 * Reads in and parses settings for the tracing
	 * Including ambient & specular weightings, and the output file dimensions and filename
	 * @param filename
	 */
	private void buildSettings(String filename)
	{
		try
		{
			//Default values
			ambient = 0.1;
			specularWeight = 0.1;
			outputDim = new int[2];
			outputDim[0] = 100;
			outputDim[1] = 100;
			outputFilename = "testOut.png";
			cameraFilename = "camera1.txt";
			sceneFilename = "scene1T.txt";
			maxRecur = 2;
			accelerationStructure = new FreeObjects();
			//End default values
			File settingsFile = new File(filename);
			Scanner settingsFileScanner = new Scanner(settingsFile);
			while(settingsFileScanner.hasNextLine())
			{
				String[] line = settingsFileScanner.nextLine().split(":");
				switch(line[0])
				{
					case "Ambient":
						ambient = Double.parseDouble(line[1]);
						break;
					case "Specular":
						specularWeight = Double.parseDouble(line[1]);
						break;
					case "OutputDim":
						String[] outputDimStr = line[1].split(" ");
						outputDim[0] = Integer.parseInt(outputDimStr[0]);
						outputDim[1] = Integer.parseInt(outputDimStr[1]);
						break;
					case "OutputFilename":
						outputFilename = line[1];
						break;
					case "CameraFilename":
						cameraFilename = line[1];
						break;
					case "SceneFilename":
						sceneFilename = line[1];
						break;
					case "MaxRecur":
						maxRecur = Integer.parseInt(line[1]);
						break;
					case "FreeObjects":
						accelerationStructure = new FreeObjects();
						break;
					case "RegularGrid":
						accelerationStructure = new RegularGrid(Integer.parseInt(line[1]));
				}
			}
			settingsFileScanner.close();
		}
		catch(Exception e)
		{
			System.out.println("Error: Cannot load settings file: " + filename);
			return;
		}
	}
	
	/**
	 * Intersects a ray with all GeometricObjects in the scene, then returns the nearest hitpoint
	 * @param cameraRay the ray to intersect
	 * @return the nearest hitpoint
	 */
	private HitPoint intersectObjects(Ray sceneRay)
	{
		return accelerationStructure.intersectRay(sceneRay);
	}
	
	/**
	 * Calculates the specular reflection component on an object at one point
	 * @param objSpec the specular exponent for the object
	 * @param norm the normal at the intersection point
	 * @param lightVec the vector to the light source
	 * @param viewVec the vector to where the ray originated from the camera
	 * @return the specular component at this point on an object
	 */
	private double calculateSpecular(double objSpec, TripletVector norm, TripletVector lightVec, TripletVector viewVec)
	{
		if(objSpec < 0)
			return 0;
		//Citation: https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF
		TripletVector r = lightVec.sub(norm.scale(norm.dot(lightVec)*2));
		r.scale(-1);
		return Math.max(Math.pow(viewVec.dot(r)*specularWeight, objSpec), 0);
	}
	
	/**
	 * Calculates the light incurred from point sources according to phong shading
	 * @param intersection the intersection point
	 * @param cameraRay the ray shot from the camera to the intersection point
	 * @param obj the object intersected with the camera ray
	 * @return diffuse and specular light from point sources according to phong shading
	 */
	private TripletVector getLightFromPointSources(TripletVector intersection, Ray viewRay, GeometricObject obj)
	{
		TripletVector additionalLight = new TripletVector(0, 0, 0);
		TripletVector objectColor = obj.getColor(intersection);
		TripletVector normal = obj.getNormal(intersection);
		for(PointLight light : pointLights)
		{
			TripletVector vecToLight = light.getLocation().sub(intersection);
			vecToLight.normalize();
			TripletVector lightRayOrigin = intersection.add(vecToLight.scale(0.001));
			Ray lightRay = new Ray(lightRayOrigin, vecToLight, -1, -1, 1.0, 1.0, 0);
			double specular = calculateSpecular(obj.getSpecular(), normal, vecToLight.scale(-1), viewRay.getDirection().scale(-1));
			double diffuse = Math.max(normal.dot(vecToLight.scale(-1.0)), 0.0);
			if(diffuse > 0)
			{
				HitPoint blocking = intersectObjects(lightRay);
				if(blocking.getObject() == null)
				{
					TripletVector lightColor = light.getColor();
					double[] colorComponents = lightColor.add(objectColor).scale(0.5).getComponents();
					additionalLight = additionalLight.add(new TripletVector(diffuse*colorComponents[0], diffuse*colorComponents[1], diffuse*colorComponents[2]));
					additionalLight = additionalLight.add(new TripletVector(specular*colorComponents[0], specular*colorComponents[1], specular*colorComponents[2]));
					colorComponents = null;
				}
			}
		}
		return additionalLight;
	}
	
	/**
	 * Samples light from all area emitters in the scene
	 * @param intersection The point we want to sample from
	 * @param viewRay the ray back to the eyepoint
	 * @param obj the object that's been intersected
	 * @return
	 */
	private TripletVector getLightFromEmitters(TripletVector intersection, Ray viewRay, GeometricObject obj)
	{
		TripletVector additionalLight = new TripletVector(0, 0, 0);
		
		TripletVector objectColor = obj.getColor(intersection);
		TripletVector normal = obj.getNormal(intersection);
		
		for(GeometricObject emitter : emitters)
		{
			ArrayList<Ray> sampleRays = emitter.getSampleRays(intersection, emitterSampleType, emitterSampleSize);
			for(Ray emitterRay : sampleRays)
			{
				HitPoint blocking = intersectObjects(emitterRay);
				if(blocking.getObject() == emitter)
				{
					TripletVector lightColor = emitter.getColor(blocking.getPoint());
					double specular = calculateSpecular(obj.getSpecular(), normal, emitterRay.getDirection().scale(-1), viewRay.getDirection().scale(-1));
					double diffuse = Math.max(normal.dot(emitterRay.getDirection().scale(-1)), 0.0);
					double[] colorComponents = lightColor.add(objectColor).scale(0.5).getComponents();
					additionalLight = additionalLight.add(new TripletVector(diffuse*colorComponents[0], diffuse*colorComponents[1], diffuse*colorComponents[2]));
					additionalLight = additionalLight.add(new TripletVector(specular*colorComponents[0], specular*colorComponents[1], specular*colorComponents[2]));
					colorComponents = null;
				}
			}
			sampleRays = null;
		}
		
		return additionalLight.scale(1.0/(double)emitterSampleSize);
	}
	
	/**
	 * Shoots an individual ray from the specified threadNum
	 * @param viewRay
	 * @param threadNum
	 */
	public void shootRay(Ray viewRay, int threadNum)
	{
		HitPoint hitp = intersectObjects(viewRay);
		int[] pixelCoords = viewRay.getPixel();
		if(hitp.getObject() != null)
		{
			GeometricObject obj = hitp.getObject();
			TripletVector intersection = hitp.getPoint();
			TripletVector objectColor = obj.getColor(intersection);
			if(!obj.isEmitter())
			{
				TripletVector sceneLight = getLightFromPointSources(intersection, viewRay, obj).add(getLightFromEmitters(intersection, viewRay, obj));
				camera.updatePixel(objectColor.scale(ambient).add(sceneLight).scale(viewRay.getWeight()*(1-obj.getReflectivity()-obj.getRefractivity())), pixelCoords);
			}
			else
				camera.updatePixel(objectColor, pixelCoords);
			
			//reflection
			if(obj.getReflectivity() > 0 && viewRay.getDepth() < maxRecur)
			{
				if(obj.getGlossyExponent() > 0)
				{
					//Glossy reflection shoots 16 vectors
					ArrayList<Ray> reflectedRays = obj.getReflectionRaysGlossy(viewRay, intersection, 16);
					for(Ray refR : reflectedRays)
					{
						processingThreads.get(threadNum).addRay(refR);
					}
				}
				else
				{
					Ray reflectedRay = obj.getReflectionRay(viewRay, intersection);
					processingThreads.get(threadNum).addRay(reflectedRay);
				}
			}
			//refraction
			if(obj.getRefractivity() > 0 && viewRay.getDepth() < maxRecur)
			{
				Ray refractedray = obj.getRefractionray(viewRay, intersection);
				processingThreads.get(threadNum).addRay(refractedray);
			}
		}
		else
		{
			camera.updatePixel(backgroundColor.scale(viewRay.getWeight()), pixelCoords);
		}
	}
			
	/**
	 * Shoots all rays from the camera, retrieves the colors from the intersected objects
	 * and the point source light, then updates the camera's film
	 */
	private void takePicture()
	{
		processingThreads = new ArrayList<RayShooter>();
		ArrayList<Ray> queuedRays = camera.getRays();
		long startTime = System.currentTimeMillis();
		
		int queueSize = queuedRays.size();
		int numThreads = 4;
		int chunkSize = Math.floorDiv(queueSize, numThreads);
		int queueIndex = 0;
		for(int i = 0; i < numThreads; i++)
		{
			RayShooter process = new RayShooter(i, this);
			int[] lastPixel = null;
			for(int j = 0; j < chunkSize; j++)
			{
				if(queueIndex >= queueSize)
					break;
				Ray rayToAdd = queuedRays.get(queueIndex);
				lastPixel = rayToAdd.getPixel();
				process.addRay(rayToAdd);
				queueIndex++;
			}
			while(queueIndex < queueSize && queuedRays.get(queueIndex).getPixel() == lastPixel)
			{
				process.addRay(queuedRays.get(queueIndex));
				queueIndex++;
			}
			processingThreads.add(process);
		}
		for(; queueIndex < queueSize; queueIndex++)
		{
			processingThreads.get(numThreads-1).addRay(queuedRays.get(queueIndex));
		}
		ExecutorService exec = Executors.newFixedThreadPool(numThreads);
		try
		{
			List<Future<Double>> threadOut = exec.invokeAll(processingThreads);
			for(Future<Double> f : threadOut)
			{
				System.out.println("THREAD FINISHED IN " + f.get() + " ITERATIONS");
			}
		}
		catch(InterruptedException | ExecutionException e)
		{
			e.printStackTrace();
		}
		exec.shutdown();
		
		long endTime = System.currentTimeMillis();
		DecimalFormat df = new DecimalFormat("###.###");
		df.setRoundingMode(RoundingMode.HALF_DOWN);
		System.out.println(df.format((endTime - startTime)*0.001) + " Seconds");
	}
	
	/**
	 * Builds tracer from a settings file
	 * @param filename name of the settings file
	 */
	public void loadFromFile(String filename)
	{
		System.out.println("Loading Files");
		buildSettings("src/config/settings/" + filename);
		buildScene("src/config/scene/" + sceneFilename);
		buildCamera("src/config/camera/" + cameraFilename);
	}
	
	public void renderToFile(String optionalFilename)
	{
		System.out.println("Rendering Scene: " + sceneObjects.size() + " Objects");
		takePicture();
		
		if(optionalFilename == null)
		{
			System.out.println("Writing to File: " + outputFilename);
			camera.writeImage(outputFilename, outputDim);
		}
		else
		{
			System.out.println("Writing to File: " + optionalFilename);
			camera.writeImage(optionalFilename, outputDim);
		}
		System.out.println("Done");
	}
	
	/**
	 * Highest level control 
	 */
	public TracingCoordinator()
	{
		//loadFromFile("settings_Bunny.txt");
		//renderToFile(null, null);
	}
}
